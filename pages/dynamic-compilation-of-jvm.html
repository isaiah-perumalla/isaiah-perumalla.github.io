<!DOCTYPE html>
<html lang="en">
<head>
        <title>Dynamic Compilation of JVM</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name=viewport content="width=device-width, initial-scale=1">
        <meta name=”description” content=”isaiah perumalla tech blog, Alogrithms, Java, Java performance, profiling, linux, Python, Linux”>
        <link href="/theme/css/theme.css" rel="stylesheet">
        <link href="/theme/css/code_styles.css" rel="stylesheet">
        <link href="/theme/css/custom.css" rel="stylesheet">
        <link href="/theme/css/sanitize.css" rel="stylesheet">

        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-134619110-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-134619110-1');
</script>

</head>

<body id="index" class="home">
<header id="page-header">
<div id="site-title" class="col span_6">
    </div>
        <nav id="social">
            <ul>
            <li><a href="/index.html">Home</a></li>
            <li><a href="/pages/about.html">About</a></li>
            
            
        </ul>
        </nav><!-- /#menu -->

    </header> 
    <h1>Dynamic Compilation of JVM</h1>
    

    <p>One of the most crucial parts of the Java Virtual Machine is the Just-In-Time (JIT) compiler; understanding how JVM dynamic compilation and optimization work is key to getting a sense of how to measure and improve performace of JVM applications by writing <strong>JIT friendly</strong> applications. Having a mental model of how code execution can help us make informed decision. 
The other key point Micro benchmarking is hard to get right in general, but it is even harder to get right on JVM due the adpative nature of the compiler.</p>
<p>1) <a href="#jvm-exe">JVM code execution in a nutshell</a>
2) <a href="">Perils of microbenchmarking</a>
3) <a href="#measure-dont-guess">case for measuring JVM applications</a></p>
<h2><a name="jvm-exe"> JVM code execution in a nutshell </a></h2>
<blockquote>
<p>How does the JVM actually executes byte code ?</p>
</blockquote>
<p>This should provide motivation for why it is even more important to measure and identify hotspots in your application code .
The runtime execution of Java code is far more complex than native C/C++ applications, for example gcc comipler compiles and optimizes C code Ahead of time (AOT), which means we can use a disassemble on binaries to see exactly the machine code which will run on the hardware.
JVM on the other hand is very <strong>adaptive system</strong>, code compilation and optimization are performed at runtime <strong>continously</strong> and highly dependend on work-load of the applicaion. we dont know the exact code executed on the cpu until runtime. A high level overview of how JVM executes code is  as outlined below</p>
<p><img alt="code execution on JVM" src="/imgs/jvm-execution.PNG"></p>
<h3>Compiler</h3>
<p>Java source code is compiled into <strong>java bytecode</strong>, but this isnt machine code which a cpu can execute, it is simply a machine independent intermediate representation. In particular the <code>javac</code> compiler simply transforms java source code to java Bytecode doing minmal, elementary optimization at compile time.</p>
<h3>Classloader</h3>
<p>class files containing byte code are loaded through the class loader, the class loader mechanism does security checks and verifies the byte code before it is executed.</p>
<h3>Byte Code Interpreter</h3>
<p>All code exectuion is first done through the byte code interpreter, once the .class files are loaded by class loader the method that are execution is store in reserved area of memory called the <strong>Method Cache</strong>, this contains verified byte code for each method.
Interpreter is stack based machine which executes method by reading methods from the method cache and executing byte code one at a time. While the interpreter is executing code, background threads in JVM keep track and gather statistics on which methods/parts of method are executed and how frequently</p>
<h3>Dynamic Runtime Compilation</h3>
<h4>Profile Guided Optimising Compiler</h4>
<p>Initially all byte-code run in interpreter mode, while the interpreter is executing code, background threads in JVM observe and gather statistics (invocation counts) on which methods and what parts of the method bytecode from the <strong>Method Cache</strong> are most commonly run. The information that has been collected about the execution of the app is called a <strong>profile</strong>. The compiler can then use this *<em>profile</em> to perform optimizations, this technique is often reffered to as profile-guided optimization (PGO). 
<img alt="profile guided optimization" src="/imgs/duke-checking.gif"></p>
<p>Once a <strong>hot method</strong> has been indetified by the optimizer, the method is compiled to highly optimized machine code. This machine code, is stored in a region of memory called <strong>Code Cache</strong>. Once machine code for the method is in the code-cache the JVM patches the method dispatch table to point to the machine-code, so subsequent calls to the method will execute the machine code directly on the CPU. </p>
<h4>JIT Optimizations</h4>
<p>Most compilers can perform static optimizations, however true power of the JVM is the ability to perform <strong>Speculative optimzations</strong> - The JVM is continously profiling the executed code, the JIT can use this data to take a 'gamble' and make aggresive optimizations for the common based on runtime information. However this kind of optimization comes with a cost, for speculative optimization to work the JVM needs to also be able to <strong>deoptimize</strong> (undo the optimization) if for example the any optimzations based on assumptions made are no longer true. 
-- picture of circle with deoptimzation</p>
<p>For example all methods are virtual by default in Java, but JIT compiler can remove the overhead of virtual method dispatches and turned into static method call (fixed address call) or even inlined at the call site <strong>if</strong> the at runtime there at the call site only a single type in a heirachy is executed. However if at a later point a new type from the class heirachy is loaded, the JIT will have to deoptimize, that is machine code is removed from the <strong>Code Cache</strong> and execution reverts back to running bytecode through the interpreter until next JIT compilation, this means generated machine code for a particular method can be invalidated by changes to the running program must be thrown away and potentially regenerated.</p>
<p>-- picture of non entrant</p>
<h5>Tiered Compilation</h5>
<p>The current openJDK implementations have two JIT compilers, the <strong>client compiler</strong> (C1) which can produce machine code quickly however not with aggresive optimization. The other compiler known as <strong>server compiler</strong> or C2 take a bit longer to produce machine code but can generate highgly optimized machine code. Previously C1 compiler was used for desktop applications and C2 for server applications, from JDK 8 onwards the default behaviour is to combine both the C1 and C2 compilers. Initially bytecode for a method is compiled with C1 and if the method is still identified as a hotspot and there is enough data collected by JVM to indicate a C2 compilation is worth while, the method is compiled a second time with further optimisations.
This is usually reffered to at <strong>Tiered Compilation</strong> and is turn on by default of all JVM version 8 onwards. <code>-XX:+/-TieredCompilation</code> can be used to enbable disable this feature. </p>
<h4>JIT Compiler(s) in Action</h4>
<p>To demonstrate the fact that java does not just run is one way and see the JIT compiler in action. We execute a simple program shown below; in this program we initialise and int array of 1 million random integers, we provide two implemenation of <code>java.util.function.IntPredicate</code> <code>class IsEven</code> and <code>class IsOdd</code> as the name suggest one implemention test to see if an int is odd and other other tests to see if the int is even.
We iterate through the array and execute the predicate and measure the execution time, we repeate this a 100 times observe how the execution times vary and how the perfomance changes as the application continues to run. We do this process once using the <code>IsOdd</code> predicate and then using <code>IsEven</code> predicate.</p>
<div class="codehilite"><pre><span></span><span class="kn">package</span> <span class="nn">net.isaiahp</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.IntPredicate</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_SIZE</span> <span class="o">=</span> <span class="mi">1000_000</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>

        <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
        <span class="n">values</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">MAX_SIZE</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">IsEven</span> <span class="kd">implements</span> <span class="n">IntPredicate</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">IsOdd</span> <span class="kd">implements</span> <span class="n">IntPredicate</span>  <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// iterate through array and apply the predicate on each int in the array</span>
    <span class="c1">//return the time in nanos  </span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">testValues</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">values</span><span class="o">,</span> <span class="n">IntPredicate</span> <span class="n">predicate</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">unused</span> <span class="o">=</span> <span class="n">predicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">runIterations</span><span class="o">(</span><span class="kt">int</span> <span class="n">ITERS</span><span class="o">,</span> <span class="n">IntPredicate</span> <span class="n">predicate</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ITERS</span><span class="o">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">time</span> <span class="o">=</span> <span class="n">testValues</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="n">predicate</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">time</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="kd">final</span> <span class="kt">int</span> <span class="n">ITERS</span> <span class="o">=</span> <span class="mi">500</span><span class="o">;</span>
        <span class="n">runIterations</span><span class="o">(</span><span class="n">ITERS</span><span class="o">,</span> <span class="k">new</span> <span class="n">IsOdd</span><span class="o">(),</span> <span class="mi">1</span><span class="o">);</span> 

        <span class="n">runIterations</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ITERS</span><span class="o">,</span> <span class="k">new</span> <span class="n">IsEven</span><span class="o">(),</span> <span class="n">ITERS</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h4>Pratical guidelines</h4>
<ul>
<li>once a hot method has been identified use <code>-XX:+PrintCompilation</code> jvm flag to verify the method was JIT compiled</li>
<li>Refactor code have smaller methods (large methods wont be JIT compiled), use JarScan to identify large method in third party jars</li>
<li>write clean idiomatic java code</li>
<li>Avoid exceptions for control flow, use only in exceptional circumstances</li>
<li>Allow JVM to warm up after restarts. </li>
</ul>
<h2><a name="measure-dont-guess"> Measure dont guess </a></h2>
<p>As we can see the number of transformations our code goes through during runtime, it does really obsure the code that is written and the actual code that is executed on the machine.
No what it does .
JVM is does a good job detecting patterns in a very large software at runtime and applies optimization dynamically, this means the code that will write <strong>will</strong> very different to the <strong>machine code</strong> that is run on the cpu, meaning any <em>micro</em> optimizations we perform as a developer may have no affect or even a negative effect at all on the runtime performance. For example optimizing a method which is never going to be JIT compiled is wasted effort, identifying <strong>hot code</strong> should always be the first step. </p>
<blockquote>
<p><strong>Does that mean we should never care about performance ? </strong></p>
</blockquote>
<p>No not at all but what it means is we should foucs on our efforts on doing <strong>micro optimization</strong> we should focus writing <strong>JIT friendly</strong> code so the JVM can do it optimization better. 
The other area to focus on is areas where an JVM can't help, these are optimization at the domain level for example<br>
<em> replace a linear search with an efficient log n algorithm
</em> how our application make use of OS resources such as threads
* implement caching if needed</p>
<p>To identify areas of bottlenecks it is important to collect data and measure the performance of a running application. Profilers are one tool every developer should use before attempting to make any performance improvements.
Following quote from Knuth sums it up nicely</p>
<blockquote>
<p><strong>"Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.Yet we should not pass up our opportunities in that critical 3%. A good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only after that code has been identified. It is often a mistake to make a priori judgments about what parts of a program are really critical, since the universal experience of programmers who have been using measurement tools has been that their intuitive guesses fail."</strong></p>
</blockquote>
<p><strong>--Donald Knuth</strong></p>


        
</body>
</html>